->Acabar RodaInstrucao.c

->Comandos I e M no P_Controle.c

->Funções de impressão no P_Impressão.c

-> Testar kkkk não faço a menor ideia quanto a bugs


#include "../Headers/RodaInstrucao.h"
void RodaInstrucao(Cpu *cpu, Time *time, EstadoEmExec *estadoexec, PcbTable *pcbTable, EstadoBloqueado *estadobloqueado, EstadoPronto *estadopronto, Processo *processo){
  char comando, instrucao[20];
  FILE *arqPrograma;
  Processo novoProcesso;
  Programa novoPrograma;
  FFilaVazia(&novoPrograma);

  strcpy(instrucao, "");

  RetiraProgramaFila(&cpu->programa, instrucao);

  /*char *p = instrucao;
  while (*p) { // While there are more characters to process...
      if (isdigit(*p) || ((*p == '-' || *p == '+') && isdigit(*(p + 1)))) {
          // Found a number
          if(cont==0){
            n[1] = strtol(p, &p, 10); // Read number
            cont++;
          }
          else{
            n[2] = strtol(p, &p, 10);
            cont=0;
          }
          printf("Primeiro inteiro extraido: %d\n", n[0]); // and print it.
          if(cont)
            printf("Segundo inteiro extraido:%d\n",n[1]);
      } else {
          // Otherwise, move on to the next character.
          p++;
      }
  }
*/
  int i = 0,n1,n2;
  const char s[2] = " ";
  char *token;
  char *aux1,*aux2,*aux3;
  token = strtok(instrucao, s);
  while( token != NULL ) {
      if(i == 0)
          aux1 = token;
      else if(i == 1)
          aux2 = token;
      else
          aux3 = token;
      token = strtok(NULL, s);
      i++;
  }
  n1 = atoi(aux2);
  n2 = atoi(aux3);
  comando = aux1[0];


  // comando = instrucao[0];

  printf("\n\t->>Primeiro parametro: %d",n1);
  printf("\n\t->>Segundo parametro: %d",n2);
  printf("\t\n-----------------Instucao -> %s",instrucao); //Debugando
  printf("Comando: %c\n", comando);

  switch (comando) {
      case 'N':
          cpu->Quant_Inteiros = 1;
          cpu->valorInteiro = (int*) malloc(sizeof(int)*cpu->Quant_Inteiros);
          break;
      case 'D':
          cpu->valorInteiro[n1] = 0;
          break;
      case 'V':  /* Define o valor da variável inteira para n, onde n é um inteiro. */
          cpu->valorInteiro[n1] = n2;
          printf("Variavel inteira: %d\n", cpu->valorInteiro[0]);
          cpu->contadorProgramaAtual++;
          time->time++;
          break;
      case 'A': /* Adiciona n ao valor da variável inteira, onde n é um inteiro. */
          cpu->valorInteiro[n1] += n2;
          printf("Variavel inteira: %d\n", cpu->valorInteiro[0]);
          cpu->contadorProgramaAtual++;
          time->time++;
          break;
      case 'S': /* Subtrai n do valor da variável inteira, onde n é um inteiro. */
          cpu->valorInteiro[n1] -= n2;
          printf("Variavel inteira: %d\n", cpu->valorInteiro[0]);
          cpu->contadorProgramaAtual++;
          time->time++;
          break;
      //
      case 'B': /* Bloqueia esse processo simulado. */
          EnfileiraBloqueado(estadobloqueado, processo);
          colocarProcessoCPU(cpu, estadopronto);
          //cpu->contadorProgramaAtual++; // Remover???
          time->time++;
          break;
      case 'T': /* Termina esse processo simulado. */
          RetiraPcbTable(pcbTable, estadoexec->iPcbTable, processo); // Precisa desalocar o programa.
          colocarProcessoCPU(cpu, estadopronto);
          time->time++;
          break;
      case 'F': /* Cria um novo processo simulado. */
          novoProcesso = criarProcessoSimulado(time, processo);
          EnfileiraPronto(estadopronto, &novoProcesso);
          InserePcbTable(pcbTable, novoProcesso);
          cpu->contadorProgramaAtual++; // Necessário para atualizar o contador do processo pai para a instrução logo após a instrução F.
          time->time++;
          break;
      case 'R': /* Substitui o programa do processo simulado pelo programa no arquivo nome_do_arquivo e define o contador de programa para a primeira instrução desse novo programa. */
          arqPrograma = fopen("./Arquivos_Entrada/Programa.txt", "r");

          if (arqPrograma == NULL) {
              printf("Erro, nao foi possivel abrir o arquivo ArquivoPrograma.txt\n");
          } else {
            int Quant_Instrucoes=0;
              while ((fgets(instrucao, sizeof(instrucao), arqPrograma)) != NULL) {
                  AdicionaProgramaFila(&novoPrograma, instrucao);
                  Quant_Instrucoes++;
              }
              novoPrograma.Tam = Quant_Instrucoes;
          }

          fclose(arqPrograma);

          cpu->contadorProgramaAtual = 0;
          cpu->valorInteiro = 0; // Indefinido?????
          time->time++;

          break;
      default:
          printf("Comando não suportado!\n");
  }

}




token = strtok(instrucao, s);
while( token != NULL ) {
  if(i == 1)
      aux2 = token;
  else
      aux3 = token;
  token = strtok(NULL, s);
  i++;
}
n1 = atoi(aux2);
n2 = atoi(aux3);
printf("%d\n", n1);
printf("%d\n", n2);
